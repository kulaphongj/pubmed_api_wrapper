---
title: "University of British Columbia - Okanagan"
author: "Craig Adlam (48226583)"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### FUNCTION BELOW RETURNS A DATAFRAME AS WELL AS THE PARAMETERS USED
```{r}
library(httr)
library(jsonlite)
library(dplyr)

Business_City <- function(city, category=NULL, limit='20') {
  # Define the main domain of the url
  domain <- "https://api.yelp.com/v3"
  
  # Define the Authorization token
  token <- "Bearer Q5ekP4HqSoGNGJul1cdaGtWjQ04GgDGV8acu1kCHbZDRM5wmhKilTcV_5_JRRzlanUBZlxrWbsviCFdgOPouOo03KfMhv6Mlva0Nptskt7pgqKo_lh5qv0rJywywZXYx"
  
  # Create a list of cities to select from
  cities <- c('Kelowna', 'Penticton', 'Red Deer', 'Edmonton', 'Calgary', 'Vancouver')
  
  # Check if the city is in the list of included cities
  if (!(city %in% cities)) {
    stop("Please select Kelowna, Penticton, Red Deer, Edmonton, Calgary, or Vancouver")
  }
  
  # Create a dictionary to store parameters
  parameters_used_city <- list(
    location = city,
    categories = category,
    limit = limit
  )
  
  # Define the URL for categories endpoint
  url_categories <- paste0(domain, "/categories")
  
  # Make request to categories endpoint
  response_categories <- GET(url_categories, add_headers(Authorization = token))
  
  # Check if the request was successful
  if (status_code(response_categories) != 200) {
    stop("Failed to retrieve data.")
  }
  
  # Extracting category titles
  raw_data_categories <- content(response_categories, "parsed")
  categories_yelp <- sapply(raw_data_categories$categories, function(category) {
    if ("parent_aliases" %in% names(category)) {
      unlist(category[["parent_aliases"]])
    } else {
      NA
    }
  })

  # Check if the category is in the list of accepted categories
  if (!(is.null(category) || category %in% unique(unlist(categories_yelp)))) {
    stop("Invalid category or categories. Please enter one or more accepted categories.")
  }
  
  # Create a dictionary to hold the parameters for the API request
  params <- list(
    location = city,
    categories = category,
    sort_by = 'best_match',
    limit = limit
  )
  
  # Define the URL for businesses search endpoint
  url_businesses <- paste0(domain, "/businesses/search?")
  
  # Request the data
  response <- GET(url_businesses, add_headers(Authorization = token), query = params)
  
  # Check if the request was successful
  if (status_code(response) != 200) {
    stop("Failed to retrieve data.")
  }
  
  # Extract the requested data
  raw_data <- content(response, "text") %>%
    fromJSON(simplifyVector = TRUE) %>%
    `[[`("businesses")
  
  # Create a DataFrame
  df_businesses <- as.data.frame(raw_data)
  
  # Select the columns of interest
  df_ratings <- df_businesses %>%
    dplyr::select(name, review_count, rating, distance, price)
  
  # Convert numerical columns to numeric format
  numeric_columns <- c('review_count', 'rating', 'distance')
  df_ratings[numeric_columns] <- lapply(df_ratings[numeric_columns], as.numeric)
  
  # Set 'name' column as the row names
  rownames(df_ratings) <- df_ratings$name
  df_ratings$name <- NULL
  
  # Map price levels to factors
  price_factors <- c("$" = 1, "$$" = 2, "$$$" = 3)
  price_factors[is.na(price_factors)] <- NULL
  
  # Add price factor column
  df_ratings$price_factor <- price_factors[df_ratings$price]
  
  # Return the resulting DataFrame and parameters used
  return(list(df_ratings = df_ratings, parameters_used_city = parameters_used_city))
}

# Example usage
result <- Business_City('Red Deer', 'food', 20)
print(result)
```

**TESTING OUT THE RETURNED DATA**
```{r}
library(ggplot2)

# Calculate average review count and rating
avg_data <- result$df_ratings %>%
  group_by(rating) %>%
  summarise(avg_review_count = mean(review_count))

# Plot the scatter plot
ggplot(avg_data, aes(x = rating, y = avg_review_count)) +
  geom_point(size = 3, color = "blue") +
  labs(x = "Rating", y = "Average Review Count", title = "Average Review Count vs Rating")

```

**USED AVERAGE RATING INSTEAD OF AVERAGE REVIEW COUNT**
```{r}
library(ggplot2)

# Calculate average review count and rating
avg_data <- result$df_ratings %>%
  group_by(review_count) %>%
  summarise(avg_rating = mean(rating))

# Plot the scatter plot
ggplot(avg_data, aes(x = review_count, y = avg_rating)) +
  geom_point(size = 3, color = "blue") +
  labs(x = "Review Count", y = "Average Rating", title = "Average Rating vs Review Count")

```

**ADDED CORRELATION**
```{r}
library(ggplot2)
library(dplyr)

# Calculate correlation coefficient
correlation <- cor(result$df_ratings$review_count, result$df_ratings$rating)

# Calculate average review count and rating
avg_data <- result$df_ratings %>%
  group_by(review_count) %>%
  summarise(avg_rating = mean(rating))

# Plot the scatter plot
ggplot(avg_data, aes(x = review_count, y = avg_rating)) +
  geom_point(size = 3, color = "blue") +
  labs(x = "Review Count", y = "Average Rating", title = "Average Rating vs Review Count") +
  geom_text(x = Inf, y = -Inf, label = paste("Correlation:", round(correlation, 2)), hjust = 1, vjust = 0, size = 4, color = "black")

```

**ADDED REGRESSION LINE**
```{r}
library(ggplot2)
library(dplyr)

# Calculate correlation coefficient
correlation <- cor(result$df_ratings$review_count, result$df_ratings$rating)

# Calculate average review count and rating
avg_data <- result$df_ratings %>%
  group_by(review_count) %>%
  summarise(avg_rating = mean(rating))

# Fit linear regression model
lm_model <- lm(avg_rating ~ review_count, data = avg_data)

# Predicted values
predicted_values <- predict(lm_model)

# Plot the scatter plot
ggplot(avg_data, aes(x = review_count, y = avg_rating)) +
  geom_point(size = 3, color = "blue") +
  geom_smooth(method = "lm", formula = y ~ x, se = FALSE, color = "red") +
  geom_text(x = Inf, y = -Inf, label = paste("Correlation:", round(correlation, 2)), hjust = 1, vjust = 0, size = 4, color = "black") +
  labs(x = "Review Count", y = "Average Rating", title = "Average Rating vs Review Count")

```

### FUNCTION BELOW RETURNS A DATAFRAME THAT INCLUDES DATA FOR EACH CITY REQUESTED, BUT NO PARAMETERS (YET)
```{r}
library(ggplot2)
library(dplyr)
library(purrr)

Business_Cities <- function(cities, category=NULL, limit='20') {
  # Define the main domain of the url
  domain <- "https://api.yelp.com/v3"
  
  # Define the Authorization token
  token <- "Bearer Q5ekP4HqSoGNGJul1cdaGtWjQ04GgDGV8acu1kCHbZDRM5wmhKilTcV_5_JRRzlanUBZlxrWbsviCFdgOPouOo03KfMhv6Mlva0Nptskt7pgqKo_lh5qv0rJywywZXYx"
  
  # Create an empty list to store results for each city
  city_results <- list()
  
  # Iterate over each city
  for (city in cities) {
    # Create a dictionary to store parameters
    parameters_used_city <- list(
      location = city,
      categories = category,
      sort_by = 'best_match',
      limit = limit
    )
    
    # Define the URL for businesses search endpoint
    url_businesses <- paste0(domain, "/businesses/search?")
    
    # Request the data
    response <- GET(url_businesses, add_headers(Authorization = token), query = parameters_used_city)
    
    # Check if the request was successful
    if (status_code(response) != 200) {
      stop("Failed to retrieve data.")
    }
    
    # Extract the requested data
    raw_data <- content(response, "text") %>%
      fromJSON(simplifyVector = TRUE) %>%
      `[[`("businesses")
    
    # Create a DataFrame
    df_businesses <- as.data.frame(raw_data)
    
    # Select the columns of interest
    df_ratings <- df_businesses %>%
      dplyr::select(name, review_count, rating, distance, price)
    
    # Convert numerical columns to numeric format
    numeric_columns <- c('review_count', 'rating', 'distance')
    df_ratings[numeric_columns] <- lapply(df_ratings[numeric_columns], as.numeric)
    
    # Store dataframe for each city
    city_results[[city]] <- df_ratings
  }
  
  # Combine dataframes for all cities into one dataframe
  combined_df <- bind_rows(city_results, .id = "City")
  
  # Return the combined dataframe
  return(combined_df)
}

# Example usage with cities
cities <- c('Kelowna', 'Penticton', 'Red Deer', 'Edmonton', 'Calgary', 'Vancouver', 'Toronto', 'Portland', 'New York City', 'San Francisco')
result <- Business_Cities(cities, 'food', 20)

# Plot scatterplot grouped by each city
ggplot(result, aes(x = review_count, y = rating, color = City, alpha=0.5)) +
  geom_point(size = 3) +
  labs(x = "Review Count", y = "Rating", title = "Scatterplot of Review Count vs Rating Grouped by City")

```

### FUNCTION BELOW RETURNS A DATAFRAME (replaced distance with price as a factor 1-3, but still need to fix it)
```{r}
library(ggplot2)
library(dplyr)
library(purrr)

Business_Cities <- function(cities, category=NULL, limit='20') {
  # Define the main domain of the url
  domain <- "https://api.yelp.com/v3"
  
  # Define the Authorization token
  token <- "Bearer Q5ekP4HqSoGNGJul1cdaGtWjQ04GgDGV8acu1kCHbZDRM5wmhKilTcV_5_JRRzlanUBZlxrWbsviCFdgOPouOo03KfMhv6Mlva0Nptskt7pgqKo_lh5qv0rJywywZXYx"
  
  # Create an empty list to store results for each city
  city_results <- list()
  
  # Iterate over each city
  for (city in cities) {
    # Create a dictionary to store parameters
    parameters_used_city <- list(
      location = city,
      categories = category,
      sort_by = 'best_match',
      limit = limit
    )
    
    # Define the URL for businesses search endpoint
    url_businesses <- paste0(domain, "/businesses/search?")
    
    # Request the data
    response <- GET(url_businesses, add_headers(Authorization = token), query = parameters_used_city)
    
    # Check if the request was successful
    if (status_code(response) != 200) {
      stop("Failed to retrieve data.")
    }
    
    # Extract the requested data
    raw_data <- content(response, "text") %>%
      fromJSON(simplifyVector = TRUE) %>%
      `[[`("businesses")
    
    # Create a DataFrame
    df_businesses <- as.data.frame(raw_data)
    
    # Select the columns of interest
    df_ratings <- df_businesses %>%
      dplyr::select(name, review_count, rating, price)
    
    # Convert price column to factor and factorize the values
    df_ratings$price <- as.factor(df_ratings$price)
    levels(df_ratings$price) <- c("$" = 1, "$$" = 2, "$$$" = 3, "nan" = NA)
    
    # Store dataframe for each city
    city_results[[city]] <- df_ratings
  }
  
  # Combine dataframes for all cities into one dataframe
  combined_df <- bind_rows(city_results, .id = "City")
  
  # Return the combined dataframe
  return(combined_df)
}

# Example usage with cities
cities <- c('Kelowna', 'Penticton', 'Red Deer', 'Edmonton', 'Calgary', 'Vancouver', 'Toronto', 'Portland', 'New York City', 'San Francisco')
result <- Business_Cities(cities, 'food', 20)

# Plot scatterplot grouped by each city
ggplot(result, aes(x = review_count, y = rating, color = City, alpha=0.5)) +
  geom_point(size = 3) +
  labs(x = "Review Count", y = "Rating", title = "Scatterplot of Review Count vs Rating Grouped by City")

```

### TESTING DIFFERENT PLOTS FROM 550 LECTURES (WILL MOST LIKELY UTILIZE DENSITY PLOTS FOR COMPARISON)  
**once the larger cities were added, due to the volume of reviews, a lot of the charts became obsolete**
```{r}
# Box plot for comparing review count across different cities and rating levels
ggplot(result, aes(x = as.factor(rating), y = review_count, fill = City)) +
  geom_boxplot() +
  labs(x = "Rating", y = "Review Count", title = "Box Plot of Review Count Across Different Cities and Rating Levels") +
  scale_x_discrete(labels = c("3.0", "3.5", "4.0", "4.5", "5.0"))
```

```{r}
# Box plot for comparing ratings across different cities
ggplot(result, aes(x = review_count, y = rating, fill = City)) +
  geom_boxplot() +
  labs(x = "City", y = "Rating", title = "Box Plot of Ratings Across Different Cities") +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

```

```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = rating, fill = City, color = City)) +
  geom_density(alpha = 0.6) +  # Density plot with transparency
  labs(x = "Rating", y = "Density", title = "Density Plot of Ratings Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1)  # Separate plots for each city

```


```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = rating, fill = City, color = City)) +
  geom_density(alpha = 0.6) +  # Density plot with transparency
  labs(x = "Rating", y = "Density", title = "Density Plot of Ratings Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1, scales = "free_y", strip.position = "bottom", shrink = TRUE, nrow = length(unique(result$City)))  # Separate plots for each city with increased height

```

### THIS PLOT WILL BE ADJUSTED AND USED AS PART OF THE FUNCTION FOR COMPARISON
```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = rating, fill = City, color = City)) +
  geom_density(alpha = 0.6) +  # Density plot with transparency
  labs(x = "Rating", y = "Density", title = "Density Plot of Ratings Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1, scales = "free_y", strip.position = "bottom", shrink = TRUE, nrow = length(unique(result$City))) +  # Separate plots for each city with increased height
  theme(strip.text = element_blank())  # Remove city names from subplots

```

**TESTING DIFFERENT COORDINATE SYSTEMS FOR SCALE/VISUALIZATION (more variability to show differences at different rating levels)**
```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = rating, fill = City, color = City)) +
  geom_density(alpha = 0.6) +  # Density plot with transparency
  labs(x = "Rating", y = "Density", title = "Density Plot of Ratings Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1, scales = "free_y", strip.position = "bottom", shrink = TRUE, nrow = length(unique(result$City))) +  # Separate plots for each city with increased height
  theme_minimal() +  # Minimal theme
  theme(strip.text = element_blank()) + # Remove city names from subplots
  theme(plot.title = element_text(size = 13), axis.title = element_text(size = 11)) +  # Adjust title and axis text sizes
  coord_cartesian(ylim = c(0, 1.0))  # Adjust the y-axis limits as needed for better visualization

```

**TESTING THE BANDWIDTH PARAMETER TO SHOW FURTHER RATING VARIATIONS BETWEEN CITIES** 
```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = rating, fill = City, color = City)) +
  geom_density(alpha = 0.6, bw = 0.05) +  # Density plot with transparency and specified bandwidth
  labs(x = "Rating", y = "Density", title = "Density Plot of Ratings Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1, scales = "free_y", strip.position = "bottom", shrink = TRUE, nrow = length(unique(result$City))) +  # Separate plots for each city with increased height
  theme_minimal() +  # Minimal theme
  theme(strip.text = element_blank()) + # Remove city names from subplots
  theme(plot.title = element_text(size = 13), axis.title = element_text(size = 11)) +  # Adjust title and axis text sizes
  coord_cartesian(ylim = c(0, 1.0))  # Adjust the y-axis limits as needed for better visualization

```

**CHANGED LAYOUT**
```{r}
# Box plot for comparing review count across different cities and rating levels
ggplot(result, aes(x = review_count, y = as.factor(rating), fill = City)) +
  geom_boxplot() +
  labs(x = "Review Count", y = "Rating", title = "Box Plot of Review Count Across Different Cities and Rating Levels") +
  scale_y_discrete(labels = c("3.0", "3.5", "4.0", "4.5", "5.0"))

```

**TESTED RUG PLOT ADDITION**
```{r}
# Box plot with rug plot for comparing review count across different cities and rating levels
ggplot(result, aes(x = review_count, y = as.factor(rating), fill = City)) +
  geom_boxplot() +  # Box plot
  geom_rug(sides = "b") +  # Rug plot at the bottom of the plot
  labs(x = "Review Count", y = "Rating", title = "Box Plot of Review Count Across Different Cities and Rating Levels") +
  scale_y_discrete(labels = c("3.0", "3.5", "4.0", "4.5", "5.0")) +
  theme_minimal()  # Minimal theme

```

**ATTEMPTED TO MAKE THE PLOT INTERACTIVE; WILL TRY ON DENSITY PLOTS**
```{r}
# Install and load required packages if not already installed
if (!requireNamespace("plotly", quietly = TRUE)) {
  install.packages("plotly")
}
library(plotly)

# Convert result dataframe to plotly format
plotly_df <- plotly::plot_ly(result, x = ~review_count, y = ~as.factor(rating), color = ~City, type = "box")

# Customize the layout
plotly_df <- plotly_df %>%
  layout(title = "Box Plot of Review Count Across Different Cities and Rating Levels",
         xaxis = list(title = "Review Count"),
         yaxis = list(title = "Rating"))

# Display the interactive plot
plotly::ggplotly(plotly_df)

```

### INCORPORATING PRICE AS A FACTOR, NEED WORK (but, appears to show some insights that could be beneficial when comparing cities)
```{r}
library(ggplot2)
library(dplyr)
library(purrr)

Business_Cities <- function(cities, category=NULL, limit='20') {
  # Define the main domain of the url
  domain <- "https://api.yelp.com/v3"
  
  # Define the Authorization token
  token <- "Bearer Q5ekP4HqSoGNGJul1cdaGtWjQ04GgDGV8acu1kCHbZDRM5wmhKilTcV_5_JRRzlanUBZlxrWbsviCFdgOPouOo03KfMhv6Mlva0Nptskt7pgqKo_lh5qv0rJywywZXYx"
  
  # Create an empty list to store results for each city
  city_results <- list()
  
  # Iterate over each city
  for (city in cities) {
    # Create a dictionary to store parameters
    parameters_used_city <- list(
      location = city,
      categories = category,
      sort_by = 'best_match',
      limit = limit
    )
    
    # Define the URL for businesses search endpoint
    url_businesses <- paste0(domain, "/businesses/search?")
    
    # Request the data
    response <- GET(url_businesses, add_headers(Authorization = token), query = parameters_used_city)
    
    # Check if the request was successful
    if (status_code(response) != 200) {
      stop("Failed to retrieve data.")
    }
    
    # Extract the requested data
    raw_data <- content(response, "text") %>%
      fromJSON(simplifyVector = TRUE) %>%
      `[[`("businesses")
    
    # Create a DataFrame
    df_businesses <- as.data.frame(raw_data)
    
    # Select the columns of interest
    df_ratings <- df_businesses %>%
      dplyr::select(name, review_count, rating, price)
    
    # Convert price column to factor and factorize the values
    df_ratings$price <- as.factor(df_ratings$price)
    levels(df_ratings$price) <- c("$" = 1, "$$" = 2, "$$$" = 3, "nan" = NA)
    
    # Store dataframe for each city
    city_results[[city]] <- df_ratings
  }
  
  # Combine dataframes for all cities into one dataframe
  combined_df <- bind_rows(city_results, .id = "City")
  
  # Return the combined dataframe
  return(combined_df)
}

# Example usage with cities
cities <- c('Kelowna', 'Penticton', 'Red Deer', 'Edmonton', 'Calgary', 'Vancouver', 'Toronto', 'Portland', 'New York City', 'San Francisco')
result <- Business_Cities(cities, 'food', 20)

# Plot scatterplot grouped by each city with 'rating' on x-axis and 'price' on y-axis
ggplot(result, aes(x = review_count, y = price, color = City, alpha=0.5)) +
  geom_point(size = 3) +
  labs(x = "Review Count", y = "Price", title = "Scatterplot of Rating vs Price Grouped by City")

```

```{r}
# Box plot for comparing review count across different cities and rating levels
ggplot(result, aes(x = review_count, y = price, fill = City)) +
  geom_boxplot() +
  labs(x = "Rating", y = "Price", title = "Box Plot of Price Across Different Cities and Rating Levels") +
  scale_x_discrete(labels = c("3.0", "3.5", "4.0", "4.5", "5.0"))
```

**STILL NEED TO WORK PRICE COLUMN OUT**
```{r}
# Density plot for comparing rating density across different cities
ggplot(result, aes(x = price, fill = City, color = City)) +
  geom_density(alpha = 0.6) +  # Density plot with transparency
  labs(x = "Price", y = "Density", title = "Density Plot of Prices Across Different Cities") +
  scale_fill_discrete(name = "City") +  # Custom legend title for fill color
  scale_color_discrete(name = "City") +  # Custom legend title for color
  facet_wrap(~ City, ncol = 1, scales = "free_y", strip.position = "bottom", shrink = TRUE, nrow = length(unique(result$City))) +  # Separate plots for each city with increased height
  theme(strip.text = element_blank())  # Remove city names from subplots
```



















